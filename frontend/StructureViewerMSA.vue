<template>
<div class="structure-panel">
    <div class="structure-wrapper" ref="structurepanel">
        <StructureViewerTooltip attach=".structure-wrapper" />
        <StructureViewerToolbar
            :isFullscreen="isFullscreen"
            @makeImage="handleMakeImage"
            @makePDB="handleMakePDB"
            @resetView="handleResetView"
            @toggleFullscreen="handleToggleFullscreen"
            disableArrowButton
            disableQueryButton
            disableTargetButton
        />
        <div class="structure-viewer" ref="viewport" />
    </div>
</div>
</template>

<script>
import StructureViewerTooltip from './StructureViewerTooltip.vue';
import StructureViewerToolbar from './StructureViewerToolbar.vue';
import StructureViewerMixin from './StructureViewerMixin.vue';
import { mockPDB, makeSubPDB, transformStructure  } from './Utilities.js';
import { download, PdbWriter, StructureRepresentation } from 'ngl';
import { pulchra } from 'pulchra-wasm';
import { tmalign, parse as parseTMOutput, parseMatrix as parseTMMatrix } from 'tmalign-wasm';

// Mock alignment object from two (MSA-derived) aligned strings
function mockAlignment(one, two) {
    let res = { backtrace: "", qAln: "", dbAln: "" };
    let started = false; // flag for first Match column in backtrace
    let m = 0;           // index in msa
    let qr = 0;          // index in seq
    let tr = 0;
    let qBuffer = "";
    let tBuffer = "";
    while (m < one.length) {
        const qc = one[m];
        const tc = two[m];
        if (qc === '-' && tc === '-') {
            // Skip gap columns
        } else if (qc === '-') {
            if (started) {
                res.backtrace += 'D';               
                qBuffer += qc;
                tBuffer += tc;
            }
            ++tr;
        } else if (tc === '-') {
            if (started) {
                res.backtrace += 'I';
                qBuffer += qc;
                tBuffer += tc;
            }
            ++qr;
        } else {
            if (started) {
                res.qAln += qBuffer;
                res.dbAln += tBuffer;
                qBuffer = "";
                tBuffer = "";
            } else {
                started = true;
                res.qStartPos = qr;
                res.dbStartPos = tr;
            }
            res.backtrace += 'M';
            qBuffer += qc;
            tBuffer += tc;
            res.qEndPos = qr;
            res.dbEndPos = tr;
            ++qr;
            ++tr;
        }
        ++m;
    }
    res.qStartPos++;
    res.dbStartPos++;
    res.qSeq  = one.replace(/-/g, '');
    res.tSeq  = two.replace(/-/g, '');
    return res;
}

export default {
    name: "StructureViewerMSA",
    components: {
        StructureViewerToolbar,
        StructureViewerTooltip,
    },
    mixins: [
        StructureViewerMixin,
    ],
    data: () => ({
        structures: [],  // { name, aa, 3di (ss), ca, NGL structure, alignment, map }
    }),
    props: {
        entries: { type: Array },
        reference: { type: Number },
        bgColorLight: { type: String, default: "white" },
        bgColorDark: { type: String, default: "#1E1E1E" },
        representationStyle: { type: String, default: "cartoon" },
    },
    methods: {
        makePDB() {
            if (!this.stage) return
            let PDB;
            let result = `\
TITLE     Superposed structures from Foldmason alignment
REMARK    This file was generated by the FoldMason webserver:
REMARK      https://mason.foldseek.com
REMARK    Please cite:
REMARK      <insert citation>
REMARK    Warning: Non C-alpha atoms may have been re-generated by PULCHRA
REMARK             if they are not present in the original PDB file.
`;
            this.structures.forEach((structure, index) => {
                PDB = new PdbWriter(structure.structure.structure, { renumberSerial: false }).getData(); 
                PDB = PDB.split('\n').filter(line => line.startsWith("ATOM")).join('\n');
                result += `\
MODEL     ${index}
REMARK    Name: ${structure.name}
${PDB}
ENDMDL
`;
            });
            result += "END";
            download(new Blob([result], { type: 'text/plain' }), "foldmason.pdb")
        },
        makeImage() {
            if (!this.stage) return
            this.stage.viewer.setLight(undefined, undefined, undefined, 0.2)
            this.stage.makeImage({
                trim: true,
                factor: (this.isFullscreen) ? 1 : 8,
                antialias: true,
                transparent: true,
            }).then((blob) => {
                this.stage.viewer.setLight(undefined, undefined, undefined, this.$vuetify.theme.dark ? 0.4 : 0.2)
                download(blob, "foldmason.png")
            })
        },
        async tmAlignToReference(index) {
            const reference = this.structures[this.reference].structure;
            const alignment = mockAlignment(this.structures[this.reference].aa, this.structures[index].aa);
            this.structures[index].alignment = alignment;
            const alnFasta = `>target\n${alignment.dbAln}\n\n>query\n${alignment.qAln}`;
            const structure = this.structures[index].structure;
            const [queryPDB, targetPDB] = await Promise.all([
                makeSubPDB(reference.structure, alignment ? `${alignment.qStartPos}-${alignment.qEndPos}` : ''),
                makeSubPDB(structure.structure, alignment ? `${alignment.dbStartPos}-${alignment.dbEndPos}` : '')
            ]);
            const { output, matrix } = await tmalign(targetPDB, queryPDB, alnFasta);
            const { t, u }  = parseTMMatrix(matrix);
            const tmResults = parseTMOutput(output);
            this.structures[index].alignment = { ...alignment, ...tmResults };
            transformStructure(this.structures[index].structure.structure, t, u);
            return Promise.resolve();
        },
        async addStructureToStage(data) {
            const { name, aa, ca } = data;
            const index = this.structures.push(data) - 1;
            const pdb = await pulchra(mockPDB(ca, aa.replace(/-/g, '')));
            const structure = await this.stage.loadFile(
                new Blob([pdb], { type: 'text/plain' }),
                {ext: 'pdb', firstModelOnly: true, name: name }
            );
            this.structures[index].index = index;
            this.structures[index].structure = structure;
            return index;
        },
        async addRepresentation({structure}, index) {
            if (structure.reprList.length > 0) {
                return;
            }
            if (this.reference !== index) {
                await this.tmAlignToReference(index);
            }
            const isReference = this.reference === index;
            structure.addRepresentation(
                this.representationStyle,
                {
                    color: isReference ? 'blue' : 'yellow',
                    opacity: isReference ? '1.0' : '0.4',
                }
            );
        },
        async shiftStructure({ structure }, index, shiftValue) {
            const { x, y, z } = structure.position;
            const offset = index * shiftValue;
            structure.setPosition({x: x + offset, y: y + offset, z: z + offset })
            this.stage.viewer.requestRender()
        },
        async explode(shiftValue) {
            if (!this.stage) return;
            this.structures.forEach((structure, index) => this.shiftStructure(structure, index, shiftValue));
            this.stage.autoView();
        },
        async updateEntries(newV, oldV) {
            if (newV.length === 0 && oldV.length === 0)
                return;
            if (!this.stage)
                return;
            oldV.filter(item => !newV.includes(item))
                .forEach(async (item) => {
                    this.stage
                        .getComponentsByName(item.name)
                        .forEach(item => this.stage.removeComponent(item));
                    const idx = this.structures.indexOf(structure => structure.name === item.name);
                    this.structures.splice(idx, 1);
                });
            newV.filter(item => !oldV.includes(item))
                .forEach(async (item) => {
                    let index = await this.addStructureToStage(item);
                    this.addRepresentation(this.structures[index], index);
                });
            this.stage.autoView();
        },
        async updateStage() {
            if (this.entries.length === 0) {
                return;
            }
            this.stage.removeAllComponents();
            this.structures = [];
            await Promise.all(this.entries.map(this.addStructureToStage));
            if (this.reference !== null) {
                await this.addRepresentation(this.structures[this.reference], this.reference);
                this.stage.autoView();
            }
            await Promise.all(this.structures.map(this.addRepresentation));
            this.stage.autoView();
        },
    },
    watch: {
        '$vuetify.theme.dark': function() {
            this.stage.viewer.setBackground(this.bgColor);
        },
        entries: async function(newV, oldV) {
            if (oldV.length === 0) {
                // first time draw = no entries in old array
                this.updateStage();
            } else {
                this.updateEntries(newV, oldV);
            }
        },
        reference: function() {
            if (!this.stage) return;
            this.updateStage();
        }
    },
    computed: {
        bgColor() {
            return this.$vuetify.theme.dark ? this.bgColorDark : this.bgColorLight;
        },
        ambientIntensity() {
            this.$vuetify.theme.dark ? 0.4 : 0.2;
        },
    },
    async mounted() {
        // this.stage.setSpin(true);
        this.updateStage();
        this.stage.autoView();
    },
}
</script>

<style>
.structure-panel {
    width: 100%;
    height: 300px;
}
.structure-viewer {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden;
}
</style>